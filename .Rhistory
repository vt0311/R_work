total <- total + i
}
print(total)
for (i in 10) {
total <- total + i
}
print(total)
for (i in 1:10) {
total <- total + i
}
print(total)
for (i in 1:10) {
total <- total + i
}
print(total)
start = 1
end = 10
total = 0
total = 0
#i <- c(1:10)
for (i in 1:10) {
total <- total + i
}
print(total)
total = 0
i <- c(1:10)
for (k in 1:10) {
total <- total + k
}
print(total)
total = 0
i <- c(1:10)
for (k in i) {
total <- total + k
}
print(total)
start = 1
end = 10
total = 0
i <- c(start:end)
for (k in i) {
total <- total + k
}
print(total)
help(cat)
scan(what = )
scan(what = '' )
data <- read.csv("C:\\Users\\acorn\\Documents\\NHIS_OPEN_T60_2006.CSV", header=TRUE)
data
head(data)
testdata <- subset(data, !is.na(금액), c(시도코드, 금액))
testdata
result <- cor(testdata)
result
round(result, digits=2)
#install.packages('corrplot')
library( corrplot )
windows()
corrplot(result, addCoef.col = "black")
# 연관 규칙 생성
install.packages("arules")
library(arules)
library(arules)
# transaction 객체 생성(파일 이용)
tran = read.transactions('tran.txt', format = "basket", sep=",")
setwd('C:/work')
# transaction 객체 생성(파일 이용)
tran = read.transactions('tran.txt', format = "basket", sep=",")
tran
library(arules)
data('Groceries')
str(Groceries)
Groceries
Groceries.df <- as(Groceries, 'data.frame')
str(Groceries.df)
head(Groceries.df)
rules = apriori(Groceries, parameter = list(supp=0.001, conf=0.8))
install.packages('arulesViz')
library(arulesViz)
# 규칙을 구성하는 왼쪽 -> 오른쪽의 item 빈도수 보기
windows()
plot(rules, method='grouped')
inspect(rules)
plot(rules, mnethod='graph', control = list(type='items'))
rules = apriori(Groceries, parameter = list(supp=0.001, conf=0.8, maxlen=3))
inspect(rules)
# 발견된 규칙 시각화
library(arulesViz)
plot(rules, mnethod='graph', control = list(type='items'))
#
plot(rules, method='graph', control = list(type='items'))
product <- read.csv('product.csv', header=T)
head(product)
str(product)
result.lm <- lm(formula = y ~ x, df)
result.lm
result.lm <- lm(formula = y ~ x, df)
result.lm
y <- product$제품_만족도
x <- product$제품_적절성
df <- data.frame(x,y)
result.lm <- lm(formula = y ~ x, df)
result.lm
# 모델의 적합값과 잔차 보기
names(result.lm)
fitted.values(result.lm)[1:2]
head(df.1)
# 모델의 적합값과 잔차 보기
names(result.lm)
# 모델의 적합 값 보기
fitted.values(result.lm)[1:2]
# 관측 값
head(df, 1)
# 잔차 계산
3-3.735963
# 모델의 잔차는 residuals() 함수를 사용하여 구할 수 있다.
residuals(result.lm)[1:2]
-0.735963 + 3.735963
# 선형 회귀 분석 모델 시각화
plot(formula = y ~ x, data = df)
# 선형 회귀 분석 모델 시각화
windows()
# 모델의 적합 값 보기
fitted.values(result.lm)[1:2]
plot(formula = y ~ x, data = df)
install.packages('car')
product
str(product)
#install.packages('car')
library(car)
plot(formula = y ~ x, data = df)
# 연관분석을 위한 패키지(arules)
library(arules)
# 단계2 : 트랜잭션 객체 생성
tran <- read.transactions('mybasket.csv' , format = 'basket', sep = ",")
tran
# 단계3 : 트랜잭션 데이터 보기
# arules 패키지에서 제공하는 inspect()함수를 이용하여 트랜잭션 객체를 확인할 수 있다.
inspect(tran)
## 2. 가장 발생 빈도가 높은 아이템은 무엇인가?
rule <- apriori(tran, parameter = list(supp=0.1, conf=0.1))
inspect(rule)
Groceries.df <- as(tran, "data.frame")
Items.df <- as(tran, "data.frame")
head(Items.df)
rules2 <- apriori(Items, parameter = list(supp=0.001, conf=0.8))
rules2 <- apriori(tran, parameter = list(supp=0.001, conf=0.8))
inspect(rules2)
windows()
plot(rules2, method="grouped")
library(arulesViz)
windows()
plot(rule2, method="graph", control=list(type="items"))
plot(rules2, method="graph", control=list(type="items"))
stran2 <- read.transactions("mybasket.csv", format = "single", sep=",")
stran2 <- read.transactions("mybasket.csv", format = "single", sep=",", cols = c(1,2))
stran2
summary(stran2)
cars
## 2. 가장 발생 빈도가 높은 아이템은 무엇인가?
#rule <- apriori(tran, parameter = list(supp=0.1, conf=0.1))
rule <- apriori(tran, parameter = list())
# party 패키지를 적용한 분류 분석
install.packages('party')
library(party)
library(datasets)
str(airquality)
formula = Temp ~ Solar.R + Wind + Ozone
air_ctree
air_ctree = ctree(formula, data=airquality)
air_ctree
windows()
plot(air_ctree)
air_ctree
set.seed(1234)
result = sample(1:nrow(iris), nrow(iris)*0.7)
result
table(result)
test = iris[-result,]
dim(train)
dim(test)
train = iris[result,]
dim(train)
formular = Species ~ Sepal.Length + Sepal.Width + Petal.Length + Petal.Width
install.packages('party')
install.packages("party")
library(party)
iris_ctree = ctree(formula, data=train)
library(party)
iris_ctree = ctree(formula, data=train)
iris_ctree
iris_ctree = ctree(formula, data=train)
formular = Species ~ Sepal.Length + Sepal.Width + Petal.Length + Petal.Width
iris_ctree = ctree(formula, data=train)
library(party)
iris_ctree = ctree(formula, data=train)
iris_ctree
formula = Species ~ Sepal.Length + Sepal.Width + Petal.Length + Petal.Width
iris_ctree = ctree(formula, data=train)
iris_ctree
# 1634번
install.packages('randomforest')
# 1634번
install.packages('randomForest')
#--------------------- 1634번-----------------------
# install.packages('randomForest')
library(randomForest)
data(iris)
# 랜덤 포레스트 모델 생성
# 참고로 iris는 150개의 행을 가지고 있다.
model <- randomForest(Species ~ ., data = iris)
model
# 정분류율이라고 한다.
(50+47+46) / nrow(iris)
# 파라미터 조정 : 트리 갯수 300, 변수 4개 지정
# na.action=na.omit : 결측치가 있으면 제거하시오.
model2 <- randomForest(Species ~ ., data = iris, ntree = 300, mtry = 4, na.action=na.omit)
model2
# 중요 변수 생성으로 랜덤 포레스트 모델 생성
# importance=T 옵션은 중요 변수 정보를 제공받겠다는 의미이다.
model3 <- randomForest(Species ~ ., data = iris, importance=T, na.action=na.omit)
# 중요 변수 보기
importance(model3)
varImpPlot( model3)
# 꽃의 종류를 분류하는 데 있어서 가장 크게 기여하는 변수는 Petal.Length으로 나타난다.
windows()
varImpPlot( model3)
library(randomForest)
ntree <- c(400, 500, 600)
mtry <- c(2:4)
param <- data.frame(n=ntree, m=mtry)
param
param
for(i in param$n) {
cat('ntree =', i, '\n')
for(j in param$m){
cat('mtry=', j, '\n')
model_iris <- randomForest(Species~., data=iris, ntree=i, mtry=j, na.action=na.omit)
cat('err.rate :', model_iris$err.rate[i], '\n\n')
}
}
print(model_iris)
# 요인 적재량 확인
loadings <- result$loadings
dim( loadings ) # 요인 적재량의 차원
dim( subject ) # 6개 과목의 차원
f응용과학 <- numeric() # 벡터 변수
f사회과학 <- numeric()
f자연과학 <- numeric()
# subject의 차원 수만큼 반복하여 개별 요인 점수를 계산한다.
for( i in 1:nrow(subject)){
fs1_num = 0 ; fs2_num = 0 ; fs3_num = 0 ;
for( k in 1:ncol(subject)){
fs1_num <- fs1_num + ( loadings[k, 1] * subject[i, k ])
fs2_num <- fs2_num + ( loadings[k, 2] * subject[i, k ])
fs3_num <- fs3_num + ( loadings[k, 3] * subject[i, k ])
} # inner for
# 개별 요인 점수를 저장한다.
f응용과학[i] <- fs1_num
f사회과학[i] <- fs2_num
f자연과학[i] <- fs3_num
}# outer for
# 개별 요인 점수를 출력한다.
f응용과학
f사회과학
f자연과학
#  [1] -0.6752039  1.5042186 -0.6752039  0.6659686  3.6391260  5.8440915
#  [1] -0.6752039  1.5042186 -0.6752039  0.6659686  3.6391260  5.8440915
#  [7]  0.4541748  4.3357697  3.4862670  5.9732138
#  [1] -0.6752039  1.5042186 -0.6752039  0.6659686  3.6391260  5.8440915
#  [7]  0.4541748  4.3357697  3.4862670  5.9732138
#  [1] -0.6752039  1.5042186 -0.6752039  0.6659686  3.6391260  5.8440915
#  [7]  0.4541748  4.3357697  3.4862670  5.9732138
#  [1] -0.6752039  1.5042186 -0.6752039  0.6659686  3.6391260  5.8440915
#  [7]  0.4541748  4.3357697  3.4862670  5.9732138
#  [1] -0.6752039  1.5042186 -0.6752039  0.6659686  3.6391260  5.8440915
#  [7]  0.4541748  4.3357697  3.4862670  5.9732138
#  [1] -0.6752039  1.5042186 -0.6752039  0.6659686  3.6391260  5.8440915
#  [7]  0.4541748  4.3357697  3.4862670  5.9732138
#  [1] -0.6752039  1.5042186 -0.6752039  0.6659686  3.6391260  5.8440915
#  [7]  0.4541748  4.3357697  3.4862670  5.9732138
#  [1] -0.6752039  1.5042186 -0.6752039  0.6659686  3.6391260  5.8440915
#  [7]  0.4541748  4.3357697  3.4862670  5.9732138
#  [1] -0.6752039  1.5042186 -0.6752039  0.6659686  3.6391260  5.8440915
#  [7]  0.4541748  4.3357697  3.4862670  5.9732138
#  [1] -0.6752039  1.5042186 -0.6752039  0.6659686  3.6391260  5.8440915
#  [7]  0.4541748  4.3357697  3.4862670  5.9732138
#  [1] -0.6752039  1.5042186 -0.6752039  0.6659686  3.6391260  5.8440915
#  [7]  0.4541748  4.3357697  3.4862670  5.9732138
#  [1] -0.6752039  1.5042186 -0.6752039  0.6659686  3.6391260  5.8440915
#  [7]  0.4541748  4.3357697  3.4862670  5.9732138
#  [1] -0.6752039  1.5042186 -0.6752039  0.6659686  3.6391260  5.8440915
#  [7]  0.4541748  4.3357697  3.4862670  5.9732138
#  [1] -0.6752039  1.5042186 -0.6752039  0.6659686  3.6391260  5.8440915
#  [7]  0.4541748  4.3357697  3.4862670  5.9732138
# 요인 적재량 확인
loadings <- result$loadings
dim( loadings ) # 요인 적재량의 차원
dim( subject ) # 6개 과목의 차원
f응용과학 <- numeric() # 벡터 변수
f사회과학 <- numeric()
f자연과학 <- numeric()
# subject의 차원 수만큼 반복하여 개별 요인 점수를 계산한다.
for( i in 1:nrow(subject)){
fs1_num = 0 ; fs2_num = 0 ; fs3_num = 0 ;
for( k in 1:ncol(subject)){
fs1_num <- fs1_num + ( loadings[k, 1] * subject[i, k ])
fs2_num <- fs2_num + ( loadings[k, 2] * subject[i, k ])
fs3_num <- fs3_num + ( loadings[k, 3] * subject[i, k ])
} # inner for
# 개별 요인 점수를 저장한다.
f응용과학[i] <- fs1_num
f사회과학[i] <- fs2_num
f자연과학[i] <- fs3_num
}# outer for
# 개별 요인 점수를 출력한다.
f응용과학
f사회과학
f자연과학
#  [1] -0.6752039  1.5042186 -0.6752039  0.6659686  3.6391260  5.8440915
install.packages('lattice')
install.packages("lattice")
library(lattice)
library(lattice)
install.packages('mlmRev')
library(mlmRev)
data(Chem97)
str(Chem97)
head(Chem97)
Chem97
histogram(~gcsescore, data=Chem97 )
install.packages('mlmRev')
library(mlmRev)
data(Chem97)
str(Chem97)
head(Chem97)
Chem97
# 히스토그램
histogram(~gcsescore, data=Chem97 )
install.packages("mlmRev")
# 히스토그램
histogram(~gcsescore, data=Chem97 )
library(mlmRev)
# 히스토그램
histogram(~gcsescore, data=Chem97 )
library(lattice)
install.packages('lattice')
library(lattice)
data(Chem97)
str(Chem97)
head(Chem97)
Chem97
install.packages("lattice")
# 히스토그램
histogram(~gcsescore, data=Chem97 )
# 히스토그램
windows()
histogram(~gcsescore, data=Chem97 )
Chem97
histogram(~gcsescore, data=Chem97 )
histogram(~gcsescore | score, data=Chem97 )
source('C:/work/8장 고급시각화 분석.R', echo=TRUE)
histogram(~gcsescore, data=Chem97 )
# 히스토그램
windows()
histogram(~gcsescore, data=Chem97 )
histogram(~gcsescore | score, data=Chem97 )
histogram(~gcsescore | factor(score), data=Chem97 )
# 밀도 그래프
densityplot(~gcsescore | factor(score), data=Chem97, groups=gender, plot.points=T, auto.key=T )
# 막대 그래프
data(VADeaths)
VADeaths
str(VADeaths)
class(VADeaths)
mode(VADeaths)
dft <- as.data.frame.table(VADeaths)
head(dft)
barchart(Var1 ~ Freq | Var2, data=dft, layout=c(4, 1))
barchart(Var1 ~ Freq | Var2, data=dft, layout=c(4, 1))
savePlot('Var1~Freq_Var2.png', type='png')
barchart(Var1 ~ Freq | Var2, data=dft, layout=c(4, 1), origin=0)
savePlot('Var1~Freq_Var2.png', type='png')
# 점 그래프
dotplot(Var1 ~ Freq | Var2, dft)
savePlot('dotplot_2by2.png', type='png')
dotplot(Var1 ~ Freq | Var2, dft, layout=c(4, 1))
savePlot('dotplot_1by4.png', type='png')
dotplot(Var1 ~ Freq, data=dft, groups=Var2, type='o',
auto.key=list(space='right', points=T, lines=T))
savePlot('dotplot_grouping.png', type='png')
# 산점도 그래프
library(datasets)
str(airquality)
xyplot(Ozone ~ Wind, data=airquality)
savePlot('xyplot_image_01.png', type='png')
xyplot(Ozone ~ Wind | Month, data=airquality)
savePlot('xyplot_basic_layout.png', type='png')
xyplot(Ozone ~ Wind | Month, data=airquality, layout=c(5,1))
savePlot('xyplot_basic_layout02.png', type='png')
convert <- transform(airquality, Month=factor(Month))
str(convert)
xyplot(Ozone ~ Wind | Month, data=convert, layout=c(5,1))
savePlot('xyplot_basic_layout03.png', type='png')
# 지진 발생 데이터셋
# quakes으로 산점도 그리기
head(quakes)
str(quakes)
# 지진 발생 진앙지 산점도
# 산점도 그래프를 변수에 저장
tplot <- xyplot(lat ~ long, data=quakes, pch='.')
tplot2 <- update(tplot, main='1964년 이후 태평양에서 발생한 지진 위치')
print(tplot2) # 그래프에 제목 추가
# 수심의 범위 파악
range(quakes$depth)
# 6개의 범주로 리코딩
quakes$depth2[quakes$depth >= 40 & quakes$depth <= 150] <- 1
quakes$depth2[quakes$depth >= 151 & quakes$depth <= 250] <- 2
quakes$depth2[quakes$depth >= 251 & quakes$depth <= 350] <- 3
quakes$depth2[quakes$depth >= 351 & quakes$depth <= 450] <- 4
quakes$depth2[quakes$depth >= 451 & quakes$depth <= 550] <- 5
quakes$depth2[quakes$depth >= 551 & quakes$depth <= 608] <- 6
# 리코딩 변수를 조건으로 산점도 그리기
convert <- transform(quakes, depth2=factor(depth2)) # factor으로 변환
xyplot(lat ~ long | depth2, data=convert)
savePlot('xyplot_basic_with_depth.png', type='png')
# 동일한 패널에 2개의 변수 값 표현
xyplot(Ozone + Solar.R ~ Wind  | factor(Month),
col=c('blue', 'red'), data=airquality, layout=c(5,1))
savePlot('y_axis_2_condition.png', type='png')
# equal.count() : 지정된 범위 대상을 범주화 해주는 함수
# 형식) equal.count(data, number, overlap)
# 비율 척도 -> 범주화로 변경할 때 유용하게 사용한다.
numgroup <- equal.count(1:150, number=4, overlap=0)
numgroup
# 지진의 깊이를 5개 영역으로 범주화
depthgroup=equal.count(quakes$depth, number=5, overlap=0)
depthgroup
# -- depthgroup변수 기준으로 플로팅
xyplot(lat ~ long | depthgroup, data=quakes,
main="Fiji Earthquakes(depthgruop)",
ylab="latitude", xlab="longitude", pch="@", col='red' )
savePlot('Fiji Earthquakes(depthgruop).png', type='png')
# 수심과 리히터 규모 변수를 동시에 적용하기
magnitudegroup=equal.count(quakes$mag, number=2, overlap=0)
magnitudegroup
# magnitudegroup 변수 기준으로 산점도 그리기
xyplot(lat ~ long | magnitudegroup, data=quakes,
main="Fiji Earthquakes(magnitudegruop)",
ylab="latitude", xlab="longitude", pch="@", col='red' )
savePlot('Fiji Earthquakes(magnitude).png', type='png')
# 수심과 리히터 규모를 동시에 표현(2행 5열 패널 구조)
# 수심(빨강), 리히터 규모(파랑)
xyplot(lat ~ long | depthgroup*magnitudegroup, data=quakes,
main="Fiji Earthquakes(magnitudegruop)",
ylab="latitude", xlab="longitude", pch="@", col='red' )
savePlot('Fiji Earthquakes(both).png', type='png')
# 이산형 변수로 리코딩 한 후 factor형으로 변환하여 산점도 그래프 그리기
quakes$depth3[quakes$depth >= 39.5 & quakes$depth < 80.5] <- 'd1'
quakes$depth3[quakes$depth >= 80.5 & quakes$depth < 186.5] <- 'd2'
quakes$depth3[quakes$depth >= 186.5 & quakes$depth < 397.5] <- 'd3'
quakes$depth3[quakes$depth >= 397.5 & quakes$depth < 562.5] <- 'd4'
quakes$depth3[quakes$depth >= 562.5 & quakes$depth < 680.5] <- 'd5'
quakes$mag3[quakes$mag >= 3.95 & quakes$mag < 4.65] <- 'm1'
quakes$mag3[quakes$mag >= 4.65 & quakes$mag < 186.5] <- 'm2'
convert <- transform(quakes, depth3=factor(depth3))
xyplot(lat ~ long | depth3*mag3, data=convert,
main="Fiji Earthquakes(magnitudegruop)",
ylab="latitude", xlab="longitude", pch="@", col='red' )
savePlot('After Recoding.png', type='png')
library(ggplot2)
korean <- read.table('학생별국어성적_new.txt', header=T, sep=',')
ggplot(korean, aes(x=이름, y=점수)) + geom_bar(stat='identity', fill='green', color='red')
gg <-  ggplot(korean, aes(x=이름, y=점수)) + geom_bar(stat='identity', fill='green', color='red')
gg + theme(axis.text.x = element_text(angle=45, hjust = 1, vjust = 1, colour = 'blue', size=8))
install.packages('gridExtra')
library(gridExtra)
cartest
cartest <- mtcars
cartest
graph1 <- ggplot(cartest, aes(x=hp, y=mpg))
graph1 + geom_point()
graph1 <- ggplot(cartest, aes(x=hp, y=mpg))
graph2 <- graph1 + geom_point(color='blue')
graph2
graph3 <- graph2 + geom_point(aes(color=factor(am)))
graph3
graph4
windows()
graph1 <- ggplot(cartest, aes(x=hp, y=mpg))
graph1 + geom_point()
graph2 <- graph1 + geom_point(color='blue')
graph2
graph3 <- graph2 + geom_point(aes(color=factor(am)))
graph3
graph4 <- graph1 + geom_point(size=7)
graph4
graph5 <- graph1 + geom_point(aes(size=wt))
graph5
# 종류 별로 크기와 모양 지정하기
graph6 <- graph1 + geom_point(aes(shape=factor(am),size=wt))
graph6
# 종류 별로 크기와 모양, 색상 지정하기
graph7 <- graph1 + geom_point(aes(shape=factor(am),color=factor(am),size=wt)) +
scale_color_manual(values=c('red', 'green'))
graph7
# 선 추가하기
graph8 <- graph1 + geom_point(color='red') + geom_line()
graph8
# x축과 y축 이름 바꾸기
graph9 <- graph1 + geom_point(color='blue') + labs(x='마력', y='연비')
graph9
