pro <- sapply(txt, extractNoun, USE.NAMES = F)
pro <- sapply(txt, extractNoun, USE.NAMES = F)
library(KoNLP)
#install.packages('rJava')
#install.packages('DBI')
#install.packages('RJDBC')
library(DBI)
Sys.setenv(JAVA_HOME='c:/program files/Java/jre1.8.0_144')
library(rJava)
library(RJDBC)
library(KoNLP)
# 1539 번 프로포즈 선물 검색
install.packages("KoNLP")
library(KoNLP)
cnt_txt <- length(txt)
txt <- readLines("propose.txt")
mode(txt)
class(txt)
pro <- sapply(txt, extractNoun, USE.NAMES = F)
head(pro)
mode(pro)
class(pro)
# list 형태로 출력됨을 확인됩니다
# 필터링을 위해 unlist 작업을 해서 저장합니다.
imsi <- unlist(pro)
pro2 <- gsub("\\.","", imsi)
pro2 <- gsub("\\n","" ,pro2)
pro2 <- gsub("\\d+","", pro2)
# 프로포즈gsub.txt : 분석 배제할 단어를 담고 있는 텍스트 파일
txt <- readLines("프로포즈gsub.txt")
txt
cnt_txt <- length(txt)
cnt_txt
txt <- readLines("propose.txt")
mode(txt)
class(txt)
pro <- sapply(txt, extractNoun, USE.NAMES = F)
head(pro)
mode(pro)
class(pro)
# list 형태로 출력됨을 확인됩니다
# 필터링을 위해 unlist 작업을 해서 저장합니다.
imsi <- unlist(pro)
pro2 <- gsub("\\.","", imsi)
pro2 <- gsub("\\n","" ,pro2)
pro2 <- gsub("\\d+","", pro2)
# 프로포즈gsub.txt : 분석 배제할 단어를 담고 있는 텍스트 파일
txt <- readLines("프로포즈gsub.txt")
txt
cnt_txt <- length(txt)
cnt_txt
for( i in 1:cnt_txt) {
pro2 <-gsub((txt[i]),"", pro2)
}
# 두 글자 이상 되는 것만 필터링하기
pro2 <- Filter(function(x) {nchar(x) >= 2}, pro2)
pro2 <- Filter(function(x) {nchar(x) <= 6} ,pro2)
head(unlist(pro2), 20)
write(unlist(pro2),"pro_3.txt")
rev <- read.table("pro_3.txt")
nrow(rev)
wordcount <- table(rev)
head(wordcount, 20)
# 큰 값을 기준으로 상위 20개만 정렬하여 보여 준다.
head(sort(wordcount, decreasing=T),20)
mydata <- head(sort(wordcount, decreasing=T),10)
bp <- barplot(mydata,  main = "프로포즈 선물 TOP 10", col = rainbow(10),
cex.names=0.7, las = 2,ylim=c(0,60))
pct <- round(mydata/sum(mydata) * 100 ,1)
# 예시 : 8건
text(x = bp, y = mydata * 1.05, labels = paste(mydata, "건"), col = "black", cex = 0.7)
# 예시 : 4.8%
text(x = bp, y = mydata * 0.85, labels = paste( "(", pct, "%", ")" ), col = "black", cex = 0.7)
bp <- barplot(mydata,  main = "프로포즈 선물 TOP 10", col = rainbow(10),
cex.names=0.7, las = 2,ylim=c(0,60))
mydata <- head(sort(wordcount, decreasing=T),10)
wordcount <- table(rev)
# 두 글자 이상 되는 것만 필터링하기
pro2 <- Filter(function(x) {nchar(x) >= 2}, pro2)
for( i in 1:cnt_txt) {
pro2 <-gsub((txt[i]),"", pro2)
}
txt <- readLines("propose.txt")
mode(txt)
class(txt)
pro <- sapply(txt, extractNoun, USE.NAMES = F)
head(pro)
mode(pro)
class(pro)
# list 형태로 출력됨을 확인됩니다
# 필터링을 위해 unlist 작업을 해서 저장합니다.
imsi <- unlist(pro)
pro2 <- gsub("\\.","", imsi)
pro2 <- gsub("\\n","" ,pro2)
pro2 <- gsub("\\d+","", pro2)
# 프로포즈gsub.txt : 분석 배제할 단어를 담고 있는 텍스트 파일
txt <- readLines("프로포즈gsub.txt")
txt
cnt_txt <- length(txt)
cnt_txt
bp <- barplot(mydata,  main = "프로포즈 선물 TOP 10", col = rainbow(10), cex.names=0.7, las = 2,ylim=c(0,60))
mydata <- head(sort(wordcount, decreasing=T),10)
wordcount <- table(rev)
head(wordcount, 20)
# 큰 값을 기준으로 상위 20개만 정렬하여 보여 준다.
head(sort(wordcount, decreasing=T),20)
mydata <- head(sort(wordcount, decreasing=T),10)
install.packages(c("KoNLP", "tm", "wordcloud"))
install.packages(c("KoNLP", "tm", "wordcloud"))
txt <- readLines("propose.txt")
mode(txt)
class(txt)
library(KoNLP)
pro <- sapply(txt, extractNoun, USE.NAMES = F)
head(pro)
mode(pro)
class(pro)
imsi <- unlist(pro)
pro2 <- gsub("\\.","", imsi)
pro2 <- gsub("\\n","" ,pro2)
pro2 <- gsub("\\d+","", pro2)
txt <- readLines("프로포즈gsub.txt")
txt
cnt_txt <- length(txt)
cnt_txt
for( i in 1:cnt_txt) {
pro2 <-gsub((txt[i]),"", pro2)
}
# 두 글자 이상 되는 것만 필터링하기(한글자 짜리는 제외한다.)
pro2 <- Filter(function(x) {nchar(x) >= 2}, pro2)
# 7자 이상도 제외한다.
pro2 <- Filter(function(x) {nchar(x) <= 6} ,pro2)
head(unlist(pro2), 20)
write(unlist(pro2),"pro_3.txt")
rev <- read.table("pro_3.txt")
nrow(rev)
wordcount <- table(rev)
head(wordcount, 20)
# 큰 값을 기준으로 상위 20개만 정렬하여 보여 준다.
head(sort(wordcount, decreasing=T),20)
mydata <- head(sort(wordcount, decreasing=T),10)
bp <- barplot(mydata,  main = "프로포즈 선물 TOP 10", col = rainbow(10), cex.names=0.7, las = 2,ylim=c(0,60))
pct <- round(mydata/sum(mydata) * 100 ,1)
# 예시 : 8건
text(x = bp, y = mydata * 1.05, labels = paste(mydata, "건"), col = "black", cex = 0.7)
# 예시 : 4.8%
text(x = bp, y = mydata * 0.85, labels = paste( "(", pct, "%", ")" ), col = "black", cex = 0.7)
windows(height = 12, width = 10)
bp <- barplot(mydata,  main = "프로포즈 선물 TOP 10", col = rainbow(10), cex.names=0.7, las = 2,ylim=c(0,60))
pct <- round(mydata/sum(mydata) * 100 ,1)
# 예시 : 8건
text(x = bp, y = mydata * 1.05, labels = paste(mydata, "건"), col = "black", cex = 0.7)
# 예시 : 4.8%
text(x = bp, y = mydata * 0.85, labels = paste( "(", pct, "%", ")" ), col = "black", cex = 0.7)
txt <- readLines("propose.txt")
pro <- sapply(txt,extractNoun,USE.NAMES=F)
pro # list 형태로 출력됨을 확인됩니다
imsi <- unlist(pro) # 필터링을 위해 unlist 작업을 해서 저장합니다.
pro2 <- gsub("\\.","", imsi)
pro2 <- gsub("\\n","",pro2)
pro2 <- gsub("\\d+","",pro2)
txt <- readLines("프로포즈gsub.txt")
txt
cnt_txt <- length(txt)
cnt_txt
for( i in 1:cnt_txt) {
pro2 <-gsub((txt[i]),"",pro2)
}
pro2 <- Filter(function(x) {nchar(x) >= 2} ,pro2) # 두 글자 이상 되는 것만 필터링하기
pro2 <- Filter(function(x) {nchar(x) <= 6} ,pro2)
head(unlist(pro2), 20)
write(unlist(pro2),"pro_3.txt")
rev <- read.table("pro_3.txt")
nrow(rev)
wordcount <- table(rev)
head(sort(wordcount, decreasing=T),20)
mydata <- head(sort(wordcount, decreasing=T),10)
pct <- round(mydata/sum(mydata) * 100 ,1)
names(mydata)
lab <- paste(names(mydata),"\n",pct,"%")
pie(mydata,main="프로포즈 선물 TOP 10",col=rainbow(10), cex=0.8,labels = lab)
windows(height = 12, width = 10)
pie(mydata,main="프로포즈 선물 TOP 10",col=rainbow(10), cex=0.8,labels = lab)
pro <- sapply(txt, extractNoun, USE.NAMES = F)
install.packages("KoNLP")
library(KoNLP)
txt <- readLines("propose.txt")
mode(txt)
class(txt)
pro <- sapply(txt, extractNoun, USE.NAMES = F)
install.packages("KoNLP")
library(KoNLP)
txt <- readLines("propose.txt")
mode(txt)
class(txt)
pro <- sapply(txt, extractNoun, USE.NAMES = F)
getwd
getwd()
# 1164번
# 기술 통계량 분석
abcCsv <- read.csv('abc.csv', header=T)
# 기본적인 데이터 특성 조회
# 몇행 몇열인가?
dim(abcCsv)
# 열의 갯수
length(abcCsv)
# price 컬럼의 행 갯수
length(abcCsv$price)
# 각 셀의 요소들의 값
str(abcCsv)
str(abcCsv$price)
summary(abcCsv)
#  Max.   :2.000   Max.   :3.000   Max.   :60.0   Max.   :7.0             Max.   :80.00   Max.   :5.0
#                                                                                         NA's   :1
#      price          survey
#  Min.   :1200   Min.   :1.0
#  1st Qu.:1200   1st Qu.:2.0
#  Median :1400   Median :3.0
#  Mean   :1860   Mean   :3.4
#  3rd Qu.:2500   3rd Qu.:5.0
#  Max.   :3000   Max.   :6.0
#  NA's   :1      NA's   :1
summary(abcCsv$price)
# 명목 척도 변수의 기술 통계량 조회
length(abcCsv$gender)
summary(abcCsv$gender)
#    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.
#   1.000   1.000   1.000   1.333   1.750   2.000
abcCsvtable <- table(abcCsv$gender)
# 1 2
# 4 2
prop.table(abcCsvtable)
y <- prop.table(abcCsvtable)
round(y*100, 2) # 100을 곱한 다음, 소수 2째자리 까지 표시
y <- prop.table(abcCsvtable)
# 서열 척도 변수의 기술 통계량 조회
length(abcCsv$position)
summary(abcCsv$position)
abcCsvPosition <- table(abcCsv$position)
abcCsvPosition #2가 1번, 4가 2번 나온다, ....
save.image("C:/work/171128.RData")
y1 <- prop.table(abcCsvPosition)
round(y1*100, 2) # 100을 곱한 다음, 소수 2째자리 까지 표시
# 비율 척도 변수의 기술 통계량 구하기
min(abcCsv$total)
# [1] 40
max(abcCsv$total)
# [1] 80
range(abcCsv$total)
# [1] 40 80
sort(abcCsv$total)
# [1] 40 50 50 60 70 80
sort(abcCsv$total, decreasing=T)
# [1] 80 70 60 50 50 40
mean(abcCsv$total)
# [1] 58.33333
# 등간 척도 변수의 기술 통계량 구하기
min(abcCsv$total) # 최소 값
# [1] 40
max(abcCsv$total) # 최대 값
# [1] 80
range(abcCsv$total) # 하한값 ~ 상한값
# [1] 40 80
sort(abcCsv$survey) # 오름차순 정렬
# [1] 1 2 3 5 6
sort(abcCsv$survey, decreasing=T) # 내림차순 정렬
# [1] 6 5 3 2 1
sort(abcCsv$price) # 오름차순 정렬(NA는 포함하지 않는다.)
# [1] 1200 1200 1400 2500 3000
sort(abcCsv$price, na.last=T) # 오름차순 정렬(NA는 마지막에 보여 준다.)
# [1] 1200 1200 1400 2500 3000   NA
min(abcCsv$price) # NA를 포함하여 최소값 구하기
# [1] NA
# NA는 배제하고 최소값 구하기
min(abcCsv$price, na.rm=T)
# [1] 1200
price2 <- abcCsv$price
price2 # 특별한 언급이 없으면 NA는 포함된다.
# [1] 1200   NA 2500 1200 1400 3000
# NA는 빼주세요.
price2 <- na.omit(abcCsv$price)
price2
# [1] 1200 2500 1200 1400 3000
# 해당 데이터 파일(csv 파일)을 로딩한다.
mycoupon <- read.csv("mycoupon.csv", header=T)
head(mycoupon) # 데이터 정보를 조회한다.
tail(mycoupon)
View(mycoupon)
# 데이터 파일에 대한 내부 구조 정보를 조회한다.
str(mycoupon)
summary(mycoupon)
# coupon 컬럼에 들어 있는 유형의 정보를 확인한다.
mycoupon$coupon
# 유형별 분할표를 만든다.
table(mycoupon$coupon)
coupon01 <- table(mycoupon$coupon)
# 분할표에 있는 쿠폰들의 유형에 대한 비율을 구한다.
prop.table( coupon01 )
# 유형의 숫자가 1은 할인 쿠폰으로, 2는 적립 쿠폰이라는 레이블을 새롭게 만든다.
mycoupon$coupon2 <- factor(mycoupon$coupon,
+ levels=c(1, 2),
+ labels=c("할인_쿠폰", "적립_쿠폰"))
# 유형의 숫자가 1은 할인 쿠폰으로, 2는 적립 쿠폰이라는 레이블을 새롭게 만든다.
mycoupon$coupon2 <- factor(mycoupon$coupon, levels=c(1, 2), labels=c("할인_쿠폰", "적립_쿠폰"))
coupon02 <- table(mycoupon$coupon2)
# 분할표에 있는 쿠폰들의 유형에 대한 비율을 구한다.
prop.table( coupon01 )
# 유형의 숫자가 1은 할인 쿠폰으로, 2는 적립 쿠폰이라는 레이블을 새롭게 만든다.
mycoupon$coupon2 <- factor(mycoupon$coupon, levels=c(1, 2), labels=c("할인_쿠폰", "적립_쿠폰"))
coupon02 <- table(mycoupon$coupon2)
# 유형별 레이블 이름에 대한 분할표를 만든다.
coupon02
# 분할표에 있는 쿠폰들의 유형에 대한 비율을 구한다.
prop.table( coupon02 )
# 최대 60의 값을 가지므로 y 눈금의 최대 값은 70으로 설정(임의 값으로 설정 가능)했다.
plot(mycoupon$coupon2, xlab="쿠폰 유형", ylab="샘플 갯수",
main="쿠폰 유형별 갯수", ylim=c(0, 70))
# 할인_쿠폰 적립_쿠폰
#       0.6       0.4
windows()
plot(mycoupon$coupon2, xlab="쿠폰 유형", ylab="샘플 갯수",
main="쿠폰 유형별 갯수", ylim=c(0, 70))
# category 컬럼에 들어 있는 유형의 정보를 확인한다.
mycoupon$category
# 유형별 분할표를 만든다.
table(mycoupon$category)
mycatetable01 <- table(mycoupon$category)
# Sum 컬럼을 확인해 보면 82이다.(결측치가 18개이다.)
addmargins(mycatetable01)
# 분할표에 있는 유형에 대한 비율을 구한다.
prop.table(mycatetable01)
myproptable01 <- prop.table(mycatetable01)
addmargins( pctproptable01 )
pctproptable01 <- round(myproptable01, 2)
addmargins( pctproptable01 )
# 카테고리 별로 레이블을 붙여서 빈도수, 백분율을 구한다.
# 쿠폰 사용 분야 데이터인 category 변수에 레이블 반영
mycoupon$category2 <- factor(mycoupon$category,
levels=c(1, 2, 3, 4),
labels=c("food", "beauty", "travel", "park"))
# 유형별 분할표를 만든다.
table(mycoupon$category2)
mycatetable02 <- table(mycoupon$category2)
addmargins(mycatetable02)
prop.table(mycatetable02)
myproptable02 <- prop.table(mycatetable02)
addmargins( pctproptable02 )
pctproptable02 <- round(myproptable02, 2)
myproptable02 <- prop.table(mycatetable02)
addmargins( pctproptable02 )
# 1128번
# 기본 기술 통계 분석(광고)
mycf <- read.csv('mycf.csv', header=T)
mycf$group
table(mycf$group)
cf01 <- table(mycf$group)
prop.table(cf01)
mycf$group2 <- factor(mycf$group, levels=c(1,2), labels=c("연예인 CF", "일반인 CF"))
mycf$group2
cf02 <- table(mycf$group2)
cf02
prop.table(cf02)
windows()
plot(mycf$group2, xlab="집단유형", ylab="샘플수", main="집단 유형별 샘플수", ylim=c(0.1700))
plot(mycf$group2, xlab="집단유형", ylab="샘플수", main="집단 유형별 샘플수", ylim=c(0, 1700))
mycf$interest
table(mycf$interest)
#    0    1
#  540 2460
myint01 <- table(mycf$interest)
prop.table( myint01 )
#    0    1
# 0.18 0.82
mycf$interest2 <- factor(mycf$interest,
levels=c(1, 0),
labels=c("관심있음", "관심없음"))
mycf$interest2
table(mycf$interest2)
# 관심있음 관심없음
#     2460      540
myint02 <- table(mycf$interest2)
prop.table( myint02 )
# 관심있음 관심없음
#     0.82     0.18
plot(mycf$interest2, xlab="광고 관심",
main="광고 관심 유무 사용자수", ylim=c(0, 2500))
# 광고에 대한 관심 유무에 따른 기술 통계 분석
mycf$interest
table(mycf$interest)
#    0    1
#  540 2460
myint01 <- table(mycf$interest)
prop.table( myint01 )
#    0    1
# 0.18 0.82
mycf$interest2 <- factor(mycf$interest,
levels=c(1, 0),
labels=c("관심있음", "관심없음"))
mycf$interest2
table(mycf$interest2)
# 관심있음 관심없음
#     2460      540
myint02 <- table(mycf$interest2)
prop.table( myint02 )
# 관심있음 관심없음
#     0.82     0.18
windows()
plot(mycf$interest2, xlab="광고 관심",
main="광고 관심 유무 사용자수", ylim=c(0, 2500))
# 변수 리코딩
# 성별을 한글로 보여주기
mycf$gender2[mycf$gender == 'M'] <- '남자'
mycf$gender2[mycf$gender == 'F'] <- '여자'
mycf$age2[mycf$age <= 40] <- '청년층'
mycf$age2[mycf$age > 40] <- '중년층'
age02 <- table(mycf$age2)
age02
prop.table(ages02)
prop.table(age02)
txt
cnt_txt
# 예시 : 8건
text(x = bp, y = mydata * 1.05, labels = paste(mydata, "건"), col = "black", cex = 0.7)
pro2
txt2
# 프로포즈gsub2.txt : 분석 포함할 단어를 담고 있는 텍스트 파일
txt2 <- readLines("프로포즈gsub2.txt")
txt2
cnt_txt2 <- length(txt2)
cnt_txt2
for( i in 1:cnt_txt2) {
pro2 <-gsub((txt2[i]),"", pro2)
}
pro2
cnt_txt2
for( i in 1:cnt_txt2) {
# pro2 중에서 txt2중에 일치하는 것이 있으면 그것을 처리한다.
pro3 <-gsub((txt2[i]),"", pro2)
}
pro3
for( i in 1:cnt_txt2) {
# pro2 중에서 txt2중에 일치하는 것이 있으면 그것을 처리한다.
#pro3 <-gsub((txt2[i]),"", pro2)
pro3 <- str_extract_all( pro2, (txt2[i]))
}
library(stringr)
for( i in 1:cnt_txt2) {
# pro2 중에서 txt2중에 일치하는 것이 있으면 그것을 처리한다.
#pro3 <-gsub((txt2[i]),"", pro2)
pro3 <- str_extract_all( pro2, (txt2[i]))
}
pro3
# 1145 번 쿠폰 사용 금액(기술 통계 분석)
#
# 사용 금액 데이터 조회
mycoupon$amount
mean(mycoupon$amount)
# 결측치를 제외한 평균 구하기(결측치 : 8개)
# 504.507336 / 92
ma = mean( mycoupon$amount, na.rm = T )
ma
round(ma, 2)
# 결측치를 가지고 있는 행은 제거하기
data <- na.omit( mycoupon )
head( data )
head( data )
data$amount
# 결측치 제거 전처리 된 데이터를 별도의 파일로 저장하기
write.csv( data, 'clean.csv' )
# quote= F : 따옴표 붙이지 않기 옵션이다.
write.csv( data, 'clean2.csv', quote= F )
hakseng <- read.csv('hakseng.csv', header=T)
hakseng
hakseng <- read.csv('hakseng.csv', sep='#', header=T)
hakseng
# 2) 각 과목의 평균 및 학생들의 평균을 구하세요.
hakseng$kor
# 2) 각 과목의 평균 및 학생들의 평균을 구하세요.
mean(hakseng$kor)
hakseng
# 2) 각 과목의 평균 및 학생들의 평균을 구하세요.
#mean(hakseng$kor)
library('plyr')
#library('dplyr')
#plyr 패키지를 이용하여 2개의 변수(member, board)를 병합하시오.
library('plyr')
board
#변수 board에 board2.csv 파일 내용을 저장하세요.
board <- read.csv('board2.csv')
#변수 member에 member2.csv 파일 내용을 저장하세요.
member <- read.csv('member2.csv', header = TRUE)
member
board
member
newdataset <- join(member, board, by='아이디')
newdataset
avg_df <- ddply(newdataset, .(이름), summarise, 조회수평균=mean(조회수), 적립포인트토탈=sum(적립포인트))
avg_df
women
#avg_df2 <- ddply(newdataset, .(이름), summarise, 적립포인트토탈=sum(적립포인트))
#newdata <- select(avg_df, avg_df2)
newdata <- ddply(newdataset, .(이름), summarise, 조회수평균=100* mean(조회수), 적립포인트토탈=sum(적립포인트))
# 2) 각 과목의 평균 및 학생들의 평균을 구하세요.
#mean(hakseng$kor)
library('plyr')
hakseng
# 문제 1.다음 물음에 답하세요.
# 1) 학생 관련 파일 hakseng.csv을 읽어 들이세요.
hakseng <- read.csv('hakseng.csv', sep='#', header=T)
hakseng
hakseng <- read.csv('hakseng.csv', sep='#', header=T)
hakseng
